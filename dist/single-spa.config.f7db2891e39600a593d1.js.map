{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../../node_modules/custom-event/index.js","webpack:///../../src/applications/app-errors.js","webpack:///../../src/applications/app.helpers.js","webpack:///../../src/applications/timeouts.js","webpack:///../../src/utils/find.js","webpack:///../../src/lifecycles/lifecycle.helpers.js","webpack:///../../src/lifecycles/bootstrap.js","webpack:///../../src/lifecycles/unmount.js","webpack:///../../src/lifecycles/mount.js","webpack:///../../src/parcels/mount-parcel.js","webpack:///../../src/lifecycles/update.js","webpack:///../../src/lifecycles/prop.helpers.js","webpack:///../../src/lifecycles/load.js","webpack:///../../src/navigation/navigation-events.js","webpack:///../../src/jquery-support.js","webpack:///../../src/lifecycles/unload.js","webpack:///../../src/applications/apps.js","webpack:///../../src/navigation/reroute.js","webpack:///../../src/start.js","webpack:///../../src/devtools/devtools.js","webpack:///../../src/single-spa.js","webpack:///(webpack)/buildin/global.js","webpack:///./single-spa.config.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","installedModules","installedCssChunks","8","__webpack_require__","exports","module","l","e","promises","Promise","resolve","reject","href","fullhref","p","existingLinkTags","document","getElementsByTagName","dataHref","tag","getAttribute","rel","existingStyleTags","linkTag","createElement","type","onload","onerror","event","request","target","src","err","Error","code","parentNode","removeChild","appendChild","then","installedChunkData","promise","onScriptComplete","script","charset","timeout","nc","setAttribute","jsonpScriptSrc","error","clearTimeout","chunk","errorType","realSrc","message","name","undefined","setTimeout","head","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","console","jsonpArray","window","oldJsonpFunction","slice","s","NativeCustomEvent","CustomEvent","detail","foo","createEvent","params","initCustomEvent","bubbles","cancelable","createEventObject","Boolean","errorHandlers","handleAppError","app","transformedErr","transformErr","forEach","handler","addErrorHandler","removeErrorHandler","removedSomething","filter","h","isHandler","ogErr","appOrParcel","result","objectType","unmountThisParcel","errPrefix","status","warn","JSON","stringify","appName","appOrParcelName","NOT_LOADED","LOADING_SOURCE_CODE","NOT_BOOTSTRAPPED","BOOTSTRAPPING","NOT_MOUNTED","MOUNTING","MOUNTED","UPDATING","UNMOUNTING","UNLOADING","LOAD_ERROR","SKIP_BECAUSE_BROKEN","isActive","isntActive","isLoaded","isntLoaded","shouldBeActive","activeWhen","location","shouldntBeActive","notSkipped","item","withoutLoadErrors","Date","getTime","loadErrorTime","toName","globalTimeoutConfig","bootstrap","millis","dieOnTimeout","mount","unmount","unload","setBootstrapMaxTime","time","setMountMaxTime","setUnmountMaxTime","setUnloadMaxTime","reasonableTime","description","timeoutConfig","warningPeriod","finished","errored","maybeTimingOut","shouldError","numWarnings","numMillis","val","catch","ensureValidAppTimeouts","timeouts","find","arr","func","validLifecycleFn","fn","Array","isArray","flattenFnArray","fns","props","waitForPromises","index","smellsLikeAPromise","toBootstrapPromise","hardFail","getProps","toUnmountPromise","unmountChildrenParcels","keys","parcels","map","parcelId","unmountAppOrParcel","parcelError","parentError","beforeFirstMountFired","firstMountFired","toMountPromise","dispatchEvent","setSkipBecauseBroken","parcelCount","rootParcels","mountRootParcel","mountParcel","apply","arguments","config","customProps","owningAppOrParcel","this","_typeof","domElement","externalRepresentation","id","passedConfigLoadingFunction","configLoadingFunction","parcel","parentName","resolveUnmount","rejectUnmount","loadPromise","bootstrapPromise","update","promiseWithoutReturnValue","mountPromise","unmountPromise","getStatus","singleSpa","unmountSelf","UserError","toLoadPromise","loadImpl","validationErrMessage","appOpts","devtools","overlays","capturedEventListeners","hashchange","popstate","routingEventsListeningTo","navigateToUrl","obj","url","opts","currentTarget","preventDefault","current","parseUri","destination","indexOf","hash","anchor","host","isTestingEnv","wouldHaveReloadedThePage","path","query","history","pushState","callCapturedEventListeners","eventArguments","eventType","listener","_this","urlReroute","reroute","addEventListener","originalAddEventListener","originalRemoveEventListener","removeEventListener","eventName","listenerFn","originalPushState","state","createPopStateEvent","originalReplaceState","replaceState","PopStateEvent","evt","initPopStateEvent","str","strictMode","q","parser","strict","loose","exec","uri","replace","$0","$1","$2","singleSpaNavigate","hasInitialized","ensureJQuerySupport","jQuery","$","jquery","originalJQueryOn","on","originalJQueryOff","off","eventString","captureRoutingEvents","originalJQueryFunction","nativeFunctionToCall","originalArgs","split","trim","appsToUnload","toUnloadPromise","unloadInfo","finishUnloadingApp","addAppToUnload","promiseGetter","apps","getMountedApps","getAppNames","getAppStatus","declareChildApplication","arg1","arg2","registerApplication","applicationOrLoadingFn","activityFn","options","selectors","checkActivityFunctions","activeApps","getAppsToLoad","unloadChildApplication","unloadApplication","waitForUnmount","App","resultPromise","appUnloadInfo","immediatelyUnloadApp","appChangeUnderway","peopleWaitingOnAppChange","triggerAppChange","pendingPromises","wasNoOp","started","getCustomEventDetail","unloadPromises","allUnmountPromises","concat","unmountAllPromise","appsToLoad","loadThenMountPromises","mountPromises","appToMount","callAllEventListeners","finishUpAndReturn","loadPromises","callEventListeners","returnValue","appChangeEventName","nextPendingPromises","pendingPromise","originalEvent","start","getRawAppData","unregisterApplication","appIndex","findIndex","splice","__SINGLE_SPA_DEVTOOLS__","exposedMethods","g","Function","commonContext","hobby","pathPrefix","prefix","pathname"],"mappings":"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","file":"single-spa.config.f7db2891e39600a593d1.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded CSS chunks\n \tvar installedCssChunks = {\n \t\t8: 0\n \t}\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t8: 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + ({\"0\":\"vendors~admin~nav~profile\",\"1\":\"admin\",\"2\":\"admin-home\",\"3\":\"admin-test\",\"4\":\"nav\",\"5\":\"profile\",\"6\":\"profile-home\",\"7\":\"profile-test\",\"9\":\"vendors~admin-home\",\"10\":\"vendors~vue\",\"11\":\"vue\"}[chunkId]||chunkId) + \".\" + {\"0\":\"fefce371c81be4cf3888\",\"1\":\"055a2dd9b79e496f67d5\",\"2\":\"0f73f9952f9db119203e\",\"3\":\"731ee43add24c31bf684\",\"4\":\"574f0d7853636bf3d468\",\"5\":\"c296a5d6c3f6a52d1cc9\",\"6\":\"4da77aceb7729430528b\",\"7\":\"ec8acf9ab3f53cc0c6ae\",\"9\":\"6b53c3917545475a2368\",\"10\":\"19965346012ee7f5d503\",\"11\":\"70004aa1b1f8a18c3fea\"}[chunkId] + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// mini-css-extract-plugin CSS loading\n \t\tvar cssChunks = {\"2\":1,\"3\":1,\"4\":1};\n \t\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n \t\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n \t\t\tpromises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {\n \t\t\t\tvar href = \"css/\" + ({\"0\":\"vendors~admin~nav~profile\",\"1\":\"admin\",\"2\":\"admin-home\",\"3\":\"admin-test\",\"4\":\"nav\",\"5\":\"profile\",\"6\":\"profile-home\",\"7\":\"profile-test\",\"9\":\"vendors~admin-home\",\"10\":\"vendors~vue\",\"11\":\"vue\"}[chunkId]||chunkId) + \".css\";\n \t\t\t\tvar fullhref = __webpack_require__.p + href;\n \t\t\t\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n \t\t\t\tfor(var i = 0; i < existingLinkTags.length; i++) {\n \t\t\t\t\tvar tag = existingLinkTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n \t\t\t\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();\n \t\t\t\t}\n \t\t\t\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n \t\t\t\tfor(var i = 0; i < existingStyleTags.length; i++) {\n \t\t\t\t\tvar tag = existingStyleTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\");\n \t\t\t\t\tif(dataHref === href || dataHref === fullhref) return resolve();\n \t\t\t\t}\n \t\t\t\tvar linkTag = document.createElement(\"link\");\n \t\t\t\tlinkTag.rel = \"stylesheet\";\n \t\t\t\tlinkTag.type = \"text/css\";\n \t\t\t\tlinkTag.onload = resolve;\n \t\t\t\tlinkTag.onerror = function(event) {\n \t\t\t\t\tvar request = event && event.target && event.target.src || fullhref;\n \t\t\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + request + \")\");\n \t\t\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n \t\t\t\t\terr.request = request;\n \t\t\t\t\tdelete installedCssChunks[chunkId]\n \t\t\t\t\tlinkTag.parentNode.removeChild(linkTag)\n \t\t\t\t\treject(err);\n \t\t\t\t};\n \t\t\t\tlinkTag.href = fullhref;\n\n \t\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\n \t\t\t\thead.appendChild(linkTag);\n \t\t\t}).then(function() {\n \t\t\t\tinstalledCssChunks[chunkId] = 0;\n \t\t\t}));\n \t\t}\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n","let errorHandlers = []\n\nexport function handleAppError(err, app) {\n  const transformedErr = transformErr(err, app);\n\n  if (errorHandlers.length) {\n    errorHandlers.forEach(handler => handler(transformedErr));\n  } else {\n    setTimeout(() => {\n      throw transformedErr;\n    });\n  }\n}\n\nexport function addErrorHandler(handler) {\n  if (typeof handler !== 'function') {\n    throw Error('a single-spa error handler must be a function');\n  }\n\n  errorHandlers.push(handler);\n}\n\nexport function removeErrorHandler(handler) {\n  if (typeof handler !== 'function') {\n    throw Error('a single-spa error handler must be a function');\n  }\n\n  let removedSomething = false;\n  errorHandlers = errorHandlers.filter(h => {\n    const isHandler = h === handler;\n    removedSomething = removedSomething || isHandler;\n    return !isHandler;\n  })\n\n  return removedSomething;\n}\n\nexport function transformErr(ogErr, appOrParcel) {\n  const objectType = appOrParcel.unmountThisParcel ? 'Parcel' : 'Application';\n  const errPrefix = `${objectType} '${appOrParcel.name}' died in status ${appOrParcel.status}: `;\n\n  let result;\n\n  if (ogErr instanceof Error) {\n    try {\n      ogErr.message = errPrefix + ogErr.message;\n    } catch(err) {\n      /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */\n    }\n    result = ogErr;\n  } else {\n    console.warn(`While ${appOrParcel.status}, '${appOrParcel.name}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`);\n    try {\n      result = Error(errPrefix + JSON.stringify(ogErr));\n    } catch(err) {\n      // If it's not an Error and you can't stringify it, then what else can you even do to it?\n      result = ogErr;\n    }\n  }\n\n  result.appName = appOrParcel.name;\n  result.appOrParcelName = appOrParcel.name;\n  try {\n    result.name = appOrParcel.name\n  } catch (err) {\n    // See https://github.com/CanopyTax/single-spa/issues/323\n    // In a future major release, we can remove the `name` property altogether,\n    // as a breaking change, in favor of appOrParcelName.\n  }\n\n  return result;\n}\n","import { handleAppError } from './app-errors.js';\n\n// App statuses\nexport const NOT_LOADED = 'NOT_LOADED';\nexport const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE';\nexport const NOT_BOOTSTRAPPED = 'NOT_BOOTSTRAPPED';\nexport const BOOTSTRAPPING = 'BOOTSTRAPPING';\nexport const NOT_MOUNTED = 'NOT_MOUNTED';\nexport const MOUNTING = 'MOUNTING';\nexport const MOUNTED = 'MOUNTED';\nexport const UPDATING = 'UPDATING';\nexport const UNMOUNTING = 'UNMOUNTING';\nexport const UNLOADING = 'UNLOADING';\nexport const LOAD_ERROR = 'LOAD_ERROR';\nexport const SKIP_BECAUSE_BROKEN = 'SKIP_BECAUSE_BROKEN';\n\nexport function isActive(app) {\n  return app.status === MOUNTED;\n}\n\nexport function isntActive(app) {\n  return !isActive(app);\n}\n\nexport function isLoaded(app) {\n  return app.status !== NOT_LOADED && app.status !== LOADING_SOURCE_CODE && app.status !== LOAD_ERROR;\n}\n\nexport function isntLoaded(app) {\n  return !isLoaded(app);\n}\n\nexport function shouldBeActive(app) {\n  try {\n    return app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app);\n    app.status = SKIP_BECAUSE_BROKEN;\n  }\n}\n\nexport function shouldntBeActive(app) {\n  try {\n    return !app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app);\n    app.status = SKIP_BECAUSE_BROKEN;\n  }\n}\n\nexport function notBootstrapped(app) {\n  return app.status !== NOT_BOOTSTRAPPED;\n}\n\nexport function notSkipped(item) {\n  return item !== SKIP_BECAUSE_BROKEN && (!item || item.status !== SKIP_BECAUSE_BROKEN);\n}\n\nexport function withoutLoadErrors(app) {\n  return app.status === LOAD_ERROR\n    ? (new Date().getTime() - app.loadErrorTime) >= 200\n    : true;\n}\n\nexport function toName(app) {\n  return app.name;\n}\n","const globalTimeoutConfig = {\n  bootstrap: {\n    millis: 4000,\n    dieOnTimeout: false,\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n};\n\nexport function setBootstrapMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`bootstrap max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.bootstrap = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setMountMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`mount max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.mount = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setUnmountMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`unmount max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.unmount = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setUnloadMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`unload max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.unload = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function reasonableTime(promise, description, timeoutConfig) {\n  const warningPeriod = 1000;\n\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n\n    promise\n    .then(val => {\n      finished = true;\n      resolve(val);\n    })\n    .catch(val => {\n      finished = true;\n      reject(val);\n    });\n\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    function maybeTimingOut(shouldError) {\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          if (timeoutConfig.dieOnTimeout) {\n            reject(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds`);\n          } else {\n            console.error(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds -- we're no longer going to warn you about it.`);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(`${description} did not resolve or reject within ${numMillis} milliseconds`);\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\nexport function ensureValidAppTimeouts(timeouts = {}) {\n  return {\n    ...globalTimeoutConfig,\n    ...timeouts,\n  }\n}\n","/* the array.prototype.find polyfill on npmjs.com is ~20kb (not worth it)\n * and lodash is ~200kb (not worth it)\n */\n\nexport function find(arr, func) {\n  for (let i=0; i<arr.length; i++) {\n    if (func(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n","import { find } from '../utils/find.js';\n\nexport function validLifecycleFn(fn) {\n  return fn && (typeof fn === 'function' || isArrayOfFns(fn));\n\n  function isArrayOfFns(arr) {\n    return Array.isArray(arr) && !find(arr, item => typeof item !== 'function');\n  }\n}\n\nexport function flattenFnArray(fns, description) {\n  fns = Array.isArray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  return function(props) {\n    return new Promise((resolve, reject) => {\n      waitForPromises(0);\n\n      function waitForPromises(index) {\n        const promise = fns[index](props);\n        if (!smellsLikeAPromise(promise)) {\n          reject(`${description} at index ${index} did not return a promise`);\n        } else {\n          promise\n            .then(() => {\n              if (index === fns.length - 1) {\n                resolve();\n              } else {\n                waitForPromises(index + 1);\n              }\n            })\n            .catch(reject);\n        }\n      }\n    });\n  }\n}\n\nexport function smellsLikeAPromise(promise) {\n  return promise && typeof promise.then === 'function' && typeof promise.catch === 'function';\n}\n","import { NOT_BOOTSTRAPPED, BOOTSTRAPPING, NOT_MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { getProps } from './prop.helpers.js'\n\nexport function toBootstrapPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n\n    appOrParcel.status = BOOTSTRAPPING;\n\n    return reasonableTime(appOrParcel.bootstrap(getProps(appOrParcel)), `Bootstrapping appOrParcel '${appOrParcel.name}'`, appOrParcel.timeouts.bootstrap)\n      .then(() => {\n        appOrParcel.status = NOT_MOUNTED;\n        return appOrParcel;\n      })\n      .catch(err => {\n        appOrParcel.status = SKIP_BECAUSE_BROKEN;\n        if (hardFail) {\n          const transformedErr = transformErr(err, appOrParcel)\n          throw transformedErr\n        } else {\n          handleAppError(err, appOrParcel);\n          return appOrParcel;\n        }\n      })\n  })\n}\n","import { UNMOUNTING, NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nexport function toUnmountPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n    appOrParcel.status = UNMOUNTING;\n\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels)\n      .map(parcelId => appOrParcel.parcels[parcelId].unmountThisParcel());\n\n    let parcelError;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(\n        unmountAppOrParcel,\n        parcelError => {\n          // There is a parcel unmount error\n          return unmountAppOrParcel()\n            .then(() => {\n              // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n              const parentError = Error(parcelError.message)\n              if (hardFail) {\n                const transformedErr = transformErr(parentError, appOrParcel)\n                appOrParcel.status = SKIP_BECAUSE_BROKEN;\n                throw transformedErr\n              } else {\n                handleAppError(parentError, appOrParcel);\n                appOrParcel.status = SKIP_BECAUSE_BROKEN;\n              }\n            })\n        }\n      )\n      .then(() => appOrParcel)\n\n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel.unmount(getProps(appOrParcel)), `Unmounting application ${appOrParcel.name}'`, appOrParcel.timeouts.unmount)\n        .then(() => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            appOrParcel.status = NOT_MOUNTED;\n          }\n        })\n        .catch(err => {\n          if (hardFail) {\n            const transformedErr = transformErr(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            throw transformedErr;\n          } else {\n            handleAppError(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n          }\n        })\n    }\n  })\n}\n","import { NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport CustomEvent from 'custom-event';\nimport { getProps } from './prop.helpers.js';\nimport { toUnmountPromise } from './unmount.js';\n\nlet beforeFirstMountFired = false;\nlet firstMountFired = false;\n\nexport function toMountPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent('single-spa:before-first-mount'));\n      beforeFirstMountFired = true;\n    }\n\n    return reasonableTime(appOrParcel.mount(getProps(appOrParcel)), `Mounting application '${appOrParcel.name}'`, appOrParcel.timeouts.mount)\n      .then(() => {\n        appOrParcel.status = MOUNTED;\n\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent('single-spa:first-mount'));\n          firstMountFired = true;\n        }\n\n        return appOrParcel;\n      })\n      .catch(err => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        appOrParcel.status = MOUNTED\n        return toUnmountPromise(appOrParcel)\n          .then(setSkipBecauseBroken, setSkipBecauseBroken)\n\n        function setSkipBecauseBroken() {\n          if (!hardFail) {\n            handleAppError(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            return appOrParcel;\n          } else {\n            const transformedErr = transformErr(err, appOrParcel)\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            throw transformedErr\n          }\n        }\n      })\n  })\n}\n","import { validLifecycleFn, flattenFnArray } from '../lifecycles/lifecycle.helpers.js';\nimport { NOT_BOOTSTRAPPED, NOT_MOUNTED, MOUNTED, UPDATING, LOADING_SOURCE_CODE, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { toBootstrapPromise } from '../lifecycles/bootstrap.js';\nimport { toMountPromise } from '../lifecycles/mount.js';\nimport { toUpdatePromise } from '../lifecycles/update.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { ensureValidAppTimeouts } from '../applications/timeouts.js';\n\nlet parcelCount = 0;\nconst rootParcels = {parcels: {}};\n\n// This is a public api, exported to users of single-spa\nexport function mountRootParcel() {\n  return mountParcel.apply(rootParcels, arguments);\n}\n\nexport function mountParcel(config, customProps) {\n  const owningAppOrParcel = this;\n\n  // Validate inputs\n  if (!config || (typeof config !== 'object' && typeof config !== 'function')) {\n    throw Error('Cannot mount parcel without a config object or config loading function');\n  }\n\n  if (config.name && typeof config.name !== 'string') {\n    throw Error('Parcel name must be a string, if provided');\n  }\n\n  if (typeof customProps !== 'object') {\n    throw Error(`Parcel ${name} has invalid customProps -- must be an object`);\n  }\n\n  if (!customProps.domElement) {\n    throw Error(`Parcel ${name} cannot be mounted without a domElement provided as a prop`);\n  }\n\n  const id = parcelCount++;\n\n  const passedConfigLoadingFunction = typeof config === 'function'\n  const configLoadingFunction = passedConfigLoadingFunction ? config : () => Promise.resolve(config)\n\n  // Internal representation\n  const parcel = {\n    id,\n    parcels: {},\n    status: passedConfigLoadingFunction ? LOADING_SOURCE_CODE : NOT_BOOTSTRAPPED,\n    customProps,\n    parentName: owningAppOrParcel.name,\n    unmountThisParcel() {\n      if (parcel.status !== MOUNTED) {\n        throw Error(`Cannot unmount parcel '${name}' -- it is in a ${parcel.status} status`);\n      }\n\n      return toUnmountPromise(parcel, true)\n        .then(value => {\n          if (parcel.parentName) {\n            delete owningAppOrParcel.parcels[parcel.id];\n          }\n\n          return value;\n        })\n        .then(value => {\n          resolveUnmount(value);\n          return value;\n        })\n        .catch(err => {\n          parcel.status = SKIP_BECAUSE_BROKEN;\n          rejectUnmount(err);\n          throw err;\n        });\n    }\n  };\n\n  // We return an external representation\n  let externalRepresentation\n\n  // Add to owning app or parcel\n  owningAppOrParcel.parcels[id] = parcel;\n\n  let loadPromise = configLoadingFunction()\n\n  if (!loadPromise || typeof loadPromise.then !== 'function') {\n    throw Error(`When mounting a parcel, the config loading function must return a promise that resolves with the parcel config`)\n  }\n\n  loadPromise = loadPromise.then(config => {\n    if (!config) {\n      throw Error(`When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config`)\n    }\n\n    const name = config.name || `parcel-${id}`;\n\n    if (!validLifecycleFn(config.bootstrap)) {\n      throw Error(`Parcel ${name} must have a valid bootstrap function`);\n    }\n\n    if (!validLifecycleFn(config.mount)) {\n      throw Error(`Parcel ${name} must have a valid mount function`);\n    }\n\n    if (!validLifecycleFn(config.unmount)) {\n      throw Error(`Parcel ${name} must have a valid unmount function`);\n    }\n\n    if (config.update && !validLifecycleFn(config.update)) {\n      throw Error(`Parcel ${name} provided an invalid update function`);\n    }\n\n    const bootstrap = flattenFnArray(config.bootstrap);\n    const mount = flattenFnArray(config.mount);\n    const unmount = flattenFnArray(config.unmount);\n\n    parcel.status = NOT_BOOTSTRAPPED;\n    parcel.name = name;\n    parcel.bootstrap = bootstrap;\n    parcel.mount = mount;\n    parcel.unmount = unmount;\n    parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n\n    if (config.update) {\n      parcel.update = flattenFnArray(config.update);\n      externalRepresentation.update = function(customProps) {\n        parcel.customProps = customProps;\n\n        return promiseWithoutReturnValue(toUpdatePromise(parcel));\n      }\n    }\n  })\n\n  // Start bootstrapping and mounting\n  // The .then() causes the work to be put on the event loop instead of happening immediately\n  const bootstrapPromise = loadPromise.then(() => toBootstrapPromise(parcel, true));\n  const mountPromise = bootstrapPromise.then(() => toMountPromise(parcel, true));\n\n  let resolveUnmount, rejectUnmount;\n\n  const unmountPromise = new Promise((resolve, reject) => {\n    resolveUnmount = resolve;\n    rejectUnmount = reject;\n  });\n\n  externalRepresentation = {\n    mount() {\n      return promiseWithoutReturnValue(\n        Promise\n        .resolve()\n        .then(() => {\n          if (parcel.status !== NOT_MOUNTED) {\n            throw Error(`Cannot mount parcel '${name}' -- it is in a ${parcel.status} status`);\n          }\n\n          // Add to owning app or parcel\n          owningAppOrParcel.parcels[id] = parcel;\n\n          return toMountPromise(parcel);\n        })\n      )\n    },\n    unmount() {\n      return promiseWithoutReturnValue(\n        parcel.unmountThisParcel()\n      );\n    },\n    getStatus() {\n      return parcel.status;\n    },\n    loadPromise: promiseWithoutReturnValue(loadPromise),\n    bootstrapPromise: promiseWithoutReturnValue(bootstrapPromise),\n    mountPromise: promiseWithoutReturnValue(mountPromise),\n    unmountPromise: promiseWithoutReturnValue(unmountPromise),\n  };\n\n  return externalRepresentation\n}\n\nfunction promiseWithoutReturnValue(promise) {\n  return promise.then(() => null);\n}\n","import { UPDATING, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nexport function toUpdatePromise(parcel) {\n  return Promise.resolve().then(() => {\n    if (parcel.status !== MOUNTED) {\n      throw Error(`Cannot update parcel '${parcel.name}' because it is not mounted`)\n    }\n\n    parcel.status = UPDATING;\n\n    return reasonableTime(parcel.update(getProps(parcel)), `Updating parcel '${parcel.name}'`, parcel.timeouts.mount)\n      .then(() => {\n        parcel.status = MOUNTED;\n        return parcel;\n      })\n      .catch(err => {\n        const transformedErr = transformErr(err, parcel)\n        parcel.status = SKIP_BECAUSE_BROKEN;\n        throw transformedErr;\n      })\n  })\n}\n\n","import * as singleSpa from '../single-spa.js'\nimport { mountParcel } from '../parcels/mount-parcel.js';\n\nexport function getProps(appOrParcel) {\n  const result = {\n    ...appOrParcel.customProps,\n    name: appOrParcel.name,\n    mountParcel: mountParcel.bind(appOrParcel),\n    singleSpa\n  };\n\n  if (appOrParcel.unmountThisParcel) {\n    result.unmountSelf = appOrParcel.unmountThisParcel;\n  }\n\n  return result;\n}\n","import { LOAD_ERROR, NOT_BOOTSTRAPPED, LOADING_SOURCE_CODE, SKIP_BECAUSE_BROKEN, NOT_LOADED } from '../applications/app.helpers.js';\nimport { ensureValidAppTimeouts } from '../applications/timeouts.js';\nimport { handleAppError } from '../applications/app-errors.js';\nimport { flattenFnArray, smellsLikeAPromise, validLifecycleFn } from './lifecycle.helpers.js';\nimport { getProps } from './prop.helpers.js';\n\nclass UserError extends Error {}\n\nexport function toLoadPromise(app) {\n  return Promise.resolve().then(() => {\n    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {\n      return app;\n    }\n\n    app.status = LOADING_SOURCE_CODE;\n\n    let appOpts;\n\n    return Promise.resolve().then(() => {\n      const loadPromise = app.loadImpl(getProps(app));\n      if (!smellsLikeAPromise(loadPromise)) {\n        // The name of the app will be prepended to this error message inside of the handleAppError function\n        throw new UserError(`single-spa loading function did not return a promise. Check the second argument to registerApplication('${app.name}', loadingFunction, activityFunction)`);\n      }\n      return loadPromise.then(val => {\n        app.loadErrorTime = null;\n\n        appOpts = val;\n\n        let validationErrMessage;\n\n        if (typeof appOpts !== 'object') {\n          validationErrMessage = `does not export anything`;\n        }\n\n        if (!validLifecycleFn(appOpts.bootstrap)) {\n          validationErrMessage = `does not export a bootstrap function or array of functions`;\n        }\n\n        if (!validLifecycleFn(appOpts.mount)) {\n          validationErrMessage = `does not export a mount function or array of functions`;\n        }\n\n        if (!validLifecycleFn(appOpts.unmount)) {\n          validationErrMessage = `does not export an unmount function or array of functions`;\n        }\n\n        if (validationErrMessage) {\n          console.error(`The loading function for single-spa application '${app.name}' resolved with the following, which does not have bootstrap, mount, and unmount functions`, appOpts)\n          handleAppError(validationErrMessage, app);\n          app.status = SKIP_BECAUSE_BROKEN;\n          return app;\n        }\n\n        if (appOpts.devtools && appOpts.devtools.overlays) {\n          app.devtools.overlays = {...app.devtools.overlays, ...appOpts.devtools.overlays}\n        }\n\n        app.status = NOT_BOOTSTRAPPED;\n        app.bootstrap = flattenFnArray(appOpts.bootstrap, `App '${app.name}' bootstrap function`);\n        app.mount = flattenFnArray(appOpts.mount, `App '${app.name}' mount function`);\n        app.unmount = flattenFnArray(appOpts.unmount, `App '${app.name}' unmount function`);\n        app.unload = flattenFnArray(appOpts.unload || [], `App '${app.name}' unload function`);\n        app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n\n        return app;\n      })\n    })\n    .catch(err => {\n      handleAppError(err, app);\n      if (err instanceof UserError) {\n        app.status = SKIP_BECAUSE_BROKEN;\n      } else {\n        app.status = LOAD_ERROR;\n        app.loadErrorTime = new Date().getTime();\n      }\n\n      return app;\n    })\n  })\n}\n","import { reroute } from './reroute.js';\nimport { find } from '../utils/find.js';\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\nconst capturedEventListeners = {\n  hashchange: [],\n  popstate: [],\n};\n\nexport const routingEventsListeningTo = ['hashchange', 'popstate'];\n\nexport function navigateToUrl(obj, opts={}) {\n  let url;\n  if (typeof obj === 'string') {\n    url = obj ;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (obj && obj.currentTarget && obj.currentTarget.href && obj.preventDefault) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(`singleSpaNavigate must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`);\n  }\n\n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n\n  if (url.indexOf('#') === 0) {\n    window.location.hash = '#' + destination.anchor;\n  } else if (current.host !== destination.host && destination.host) {\n    if (opts.isTestingEnv) {\n      return {wouldHaveReloadedThePage: true};\n    } else {\n      window.location.href = url;\n    }\n  } else if (!isSamePath(destination.path + \"?\" + destination.query, current.path + \"?\" + current.query)) {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  } else {\n    window.location.hash = '#' + destination.anchor;\n  }\n\n  function isSamePath(destination, current) {\n    // if the destination has a path but no domain, it doesn't include the root '/'\n    return current === destination || current === '/' + destination;\n  }\n}\n\nexport function callCapturedEventListeners(eventArguments) {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      capturedEventListeners[eventType].forEach(listener => {\n        listener.apply(this, eventArguments);\n      });\n    }\n  }\n}\n\nfunction urlReroute() {\n  reroute([], arguments)\n}\n\n\n// We will trigger an app change for any routing events.\nwindow.addEventListener('hashchange', urlReroute);\nwindow.addEventListener('popstate', urlReroute);\n\n// Monkeypatch addEventListener so that we can ensure correct timing\nconst originalAddEventListener = window.addEventListener;\nconst originalRemoveEventListener = window.removeEventListener;\nwindow.addEventListener = function(eventName, fn) {\n  if (typeof fn === 'function') {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0 && !find(capturedEventListeners[eventName], listener => listener === fn)) {\n      capturedEventListeners[eventName].push(fn);\n      return;\n    }\n  }\n\n  return originalAddEventListener.apply(this, arguments);\n}\n\nwindow.removeEventListener = function(eventName, listenerFn) {\n  if (typeof listenerFn === 'function') {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      capturedEventListeners[eventName] = capturedEventListeners[eventName].filter(fn => fn !== listenerFn);\n      return;\n    }\n  }\n\n  return originalRemoveEventListener.apply(this, arguments);\n}\n\nconst originalPushState = window.history.pushState;\nwindow.history.pushState = function(state) {\n  const result = originalPushState.apply(this, arguments);\n\n  urlReroute(createPopStateEvent(state));\n  \n  return result;\n}\n\nconst originalReplaceState = window.history.replaceState;\nwindow.history.replaceState = function(state) {\n  const result = originalReplaceState.apply(this, arguments);\n  urlReroute(createPopStateEvent(state));\n  return result;\n}\n\nfunction createPopStateEvent(state) {\n  // https://github.com/CanopyTax/single-spa/issues/224 and https://github.com/CanopyTax/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn't do one by default when you call replaceState, so that\n  // all the applications can reroute.\n  try {\n    return new PopStateEvent('popstate', {state});\n  } catch (err) {\n    // IE 11 compatibility https://github.com/CanopyTax/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    const evt = document.createEvent('PopStateEvent');\n    evt.initPopStateEvent('popstate', false, false, state);\n    return evt;\n  }\n}\n\n/* For convenience in `onclick` attributes, we expose a global function for navigating to\n * whatever an <a> tag's href is.\n */\nwindow.singleSpaNavigate = navigateToUrl;\n\nfunction parseUri(str) {\n  // parseUri 1.2.2\n  // (c) Steven Levithan <stevenlevithan.com>\n  // MIT License\n  // http://blog.stevenlevithan.com/archives/parseuri\n  const parseOptions = {\n    strictMode: true,\n    key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n    q:   {\n      name:   \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n\n  let  o = parseOptions;\n  let m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  let uri = {};\n  let i = 14;\n\n  while (i--) uri[o.key[i]] = m[i] || \"\";\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2;\n  });\n\n  return uri;\n}\n","import { routingEventsListeningTo } from './navigation/navigation-events.js';\n\nlet hasInitialized = false;\n\nexport function ensureJQuerySupport(jQuery = window.jQuery) {\n  if (!jQuery) {\n    if (window.$ && window.$.fn && window.$.fn.jquery) {\n      jQuery = window.$;\n    }\n  }\n\n  if (jQuery && !hasInitialized) {\n    const originalJQueryOn = jQuery.fn.on;\n    const originalJQueryOff = jQuery.fn.off;\n\n    jQuery.fn.on = function(eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOn, window.addEventListener, eventString, fn, arguments);\n    }\n\n    jQuery.fn.off = function(eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOff, window.removeEventListener, eventString, fn, arguments);\n    }\n\n    hasInitialized = true;\n  }\n}\n\nfunction captureRoutingEvents(originalJQueryFunction, nativeFunctionToCall, eventString, fn, originalArgs) {\n  if (typeof eventString !== 'string') {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n\n  const eventNames = eventString.split(/\\s+/);\n  eventNames.forEach(eventName => {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      nativeFunctionToCall(eventName, fn);\n      eventString = eventString.replace(eventName, '');\n    }\n  });\n\n  if (eventString.trim() === '') {\n    return this;\n  } else {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n}\n","import { NOT_MOUNTED, UNLOADING, NOT_LOADED, SKIP_BECAUSE_BROKEN, isntActive } from '../applications/app.helpers.js';\nimport { handleAppError } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nconst appsToUnload = {};\n\nexport function toUnloadPromise(app) {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[app.name];\n\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n      */\n      return app;\n    }\n\n    if (app.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n\n    if (app.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise.then(() => app);\n    }\n\n    if (app.status !== NOT_MOUNTED) {\n      /* The app cannot be unloaded until it is unmounted.\n      */\n      return app;\n    }\n\n    app.status = UNLOADING;\n    return reasonableTime(app.unload(getProps(app)), `Unloading application '${app.name}'`, app.timeouts.unload)\n      .then(() => {\n        finishUnloadingApp(app, unloadInfo);\n        return app;\n      })\n      .catch(err => {\n        errorUnloadingApp(app, unloadInfo, err);\n        return app;\n      })\n  })\n}\n\nfunction finishUnloadingApp(app, unloadInfo) {\n  delete appsToUnload[app.name];\n\n  // Unloaded apps don't have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  app.status = NOT_LOADED;\n\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[app.name];\n\n  // Unloaded apps don't have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app);\n  app.status = SKIP_BECAUSE_BROKEN;\n  unloadInfo.reject(err);\n}\n\nexport function addAppToUnload(app, promiseGetter, resolve, reject) {\n  appsToUnload[app.name] = {app, resolve, reject};\n  Object.defineProperty(appsToUnload[app.name], 'promise', {get: promiseGetter});\n}\n\nexport function getAppUnloadInfo(appName) {\n  return appsToUnload[appName];\n}\n\nexport function getAppsToUnload() {\n  return Object.keys(appsToUnload)\n    .map(appName => appsToUnload[appName].app)\n    .filter(isntActive)\n}\n","import { ensureJQuerySupport } from '../jquery-support.js';\nimport {\n  isActive,\n  isLoaded,\n  isntLoaded,\n  toName,\n  NOT_LOADED,\n  shouldBeActive,\n  shouldntBeActive,\n  isntActive,\n  notSkipped,\n  withoutLoadErrors,\n} from \"./app.helpers.js\";\nimport { reroute } from '../navigation/reroute.js';\nimport { find } from '../utils/find.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { toUnloadPromise, getAppUnloadInfo, addAppToUnload } from '../lifecycles/unload.js';\n\nconst apps = [];\n\nexport function getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\n\n// used in devtools, not (currently) exposed as a single-spa API\nexport function getRawAppData() {\n  return [...apps];\n}\n\nexport function getAppStatus(appName) {\n  const app = find(apps, app => app.name === appName);\n  return app ? app.status : null;\n}\n\nexport function declareChildApplication(appName, arg1, arg2) {\n  console.warn('declareChildApplication is deprecated and will be removed in the next major version, use \"registerApplication\" instead')\n  return registerApplication(appName, arg1, arg2)\n}\n\nexport function registerApplication(appName, applicationOrLoadingFn, activityFn, customProps = {}) {\n  if (typeof appName !== 'string' || appName.length === 0)\n    throw Error(`The first argument must be a non-empty string 'appName'`);\n  if (getAppNames().indexOf(appName) !== -1)\n    throw Error(`There is already an app declared with name ${appName}`);\n  if (typeof customProps !== 'object' || Array.isArray(customProps))\n    throw Error('customProps must be an object');\n\n  if (!applicationOrLoadingFn)\n    throw Error(`The application or loading function is required`);\n\n  let loadImpl;\n  if (typeof applicationOrLoadingFn !== 'function') {\n    // applicationOrLoadingFn is an application\n    loadImpl = () => Promise.resolve(applicationOrLoadingFn);\n  } else {\n    // applicationOrLoadingFn is a loadingFn\n    loadImpl = applicationOrLoadingFn;\n  }\n\n  if (typeof activityFn !== 'function')\n    throw Error(`The activeWhen argument must be a function`);\n\n  apps.push({\n    loadErrorTime: null,\n    name: appName,\n    loadImpl,\n    activeWhen: activityFn,\n    status: NOT_LOADED,\n    parcels: {},\n    devtools: {\n      overlays: {\n        options: {},\n        selectors: [],\n      }\n    },\n    customProps\n  });\n\n  ensureJQuerySupport();\n\n  reroute();\n}\n\nexport function checkActivityFunctions(location) {\n  const activeApps = []\n  for (let i = 0; i < apps.length; i++) {\n    if (apps[i].activeWhen(location)) {\n      activeApps.push(apps[i].name)\n    }\n  }\n  return activeApps\n}\n\nexport function getAppsToLoad() {\n  return apps\n    .filter(notSkipped)\n    .filter(withoutLoadErrors)\n    .filter(isntLoaded)\n    .filter(shouldBeActive)\n}\n\nexport function getAppsToUnmount() {\n  return apps\n    .filter(notSkipped)\n    .filter(isActive)\n    .filter(shouldntBeActive)\n}\n\nexport function getAppsToMount() {\n  return apps\n    .filter(notSkipped)\n    .filter(isntActive)\n    .filter(isLoaded)\n    .filter(shouldBeActive)\n}\n\nexport function unregisterApplication(appName) {\n  if (!apps.find(app => app.name === appName)) {\n    throw Error(`Cannot unregister application '${appName}' because no such application has been registered`)\n  }\n\n  return unloadApplication(appName)\n    .then(() => {\n      const appIndex = apps.findIndex(app => app.name === appName)\n      apps.splice(appIndex, 1)\n    })\n}\n\nexport function unloadChildApplication(appName, opts) {\n  console.warn('unloadChildApplication is deprecated and will be removed in the next major version, use \"unloadApplication\" instead')\n  return unloadApplication(appName, opts)\n}\n\nexport function unloadApplication(appName, opts={waitForUnmount: false}) {\n  if (typeof appName !== 'string') {\n    throw Error(`unloadApplication requires a string 'appName'`);\n  }\n  const app = find(apps, App => App.name === appName);\n  if (!app) {\n    throw Error(`Could not unload application '${appName}' because no such application has been registered`);\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(app.name);\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n\n    let resultPromise;\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  toUnmountPromise(app)\n    .then(toUnloadPromise)\n    .then(() => {\n      resolve()\n      setTimeout(() => {\n        // reroute, but the unload promise is done\n        reroute()\n      });\n    })\n    .catch(reject);\n}\n","import CustomEvent from 'custom-event';\nimport { isStarted } from '../start.js';\nimport { toLoadPromise } from '../lifecycles/load.js';\nimport { toBootstrapPromise } from '../lifecycles/bootstrap.js';\nimport { toMountPromise } from '../lifecycles/mount.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { getMountedApps, getAppsToLoad, getAppsToUnmount, getAppsToMount } from '../applications/apps.js';\nimport { callCapturedEventListeners } from './navigation-events.js';\nimport { getAppsToUnload, toUnloadPromise } from '../lifecycles/unload.js';\n\nlet appChangeUnderway = false, peopleWaitingOnAppChange = [];\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute()\n}\n\nexport function reroute(pendingPromises = [], eventArguments) {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  appChangeUnderway = true;\n  let wasNoOp = true;\n\n  if (isStarted()) {\n    return performAppChanges();\n  } else {\n    return loadApps();\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      const loadPromises = getAppsToLoad().map(toLoadPromise);\n\n      if (loadPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      return Promise\n        .all(loadPromises)\n        .then(finishUpAndReturn)\n        .catch(err => {\n          callAllEventListeners();\n          throw err;\n        })\n    })\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      window.dispatchEvent(new CustomEvent(\"single-spa:before-routing-event\", getCustomEventDetail()));\n      const unloadPromises = getAppsToUnload().map(toUnloadPromise);\n\n      const unmountUnloadPromises = getAppsToUnmount()\n        .map(toUnmountPromise)\n        .map(unmountPromise => unmountPromise.then(toUnloadPromise));\n\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      if (allUnmountPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      const appsToLoad = getAppsToLoad();\n\n      /* We load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      const loadThenMountPromises = appsToLoad.map(app => {\n        return toLoadPromise(app)\n          .then(toBootstrapPromise)\n          .then(app => {\n            return unmountAllPromise\n              .then(() => toMountPromise(app))\n          })\n      })\n      if (loadThenMountPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      /* These are the apps that are already bootstrapped and just need\n       * to be mounted. They each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      const mountPromises = getAppsToMount()\n        .filter(appToMount => appsToLoad.indexOf(appToMount) < 0)\n        .map(appToMount => {\n          return toBootstrapPromise(appToMount)\n            .then(() => unmountAllPromise)\n            .then(() => toMountPromise(appToMount))\n        })\n      if (mountPromises.length > 0) {\n        wasNoOp = false;\n      }\n      return unmountAllPromise\n        .catch(err => {\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it's safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          callAllEventListeners();\n\n          return Promise\n            .all(loadThenMountPromises.concat(mountPromises))\n            .catch(err => {\n              pendingPromises.forEach(promise => promise.reject(err));\n              throw err;\n            })\n            .then(() => finishUpAndReturn(false))\n        })\n\n    })\n  }\n\n  function finishUpAndReturn(callEventListeners=true) {\n    const returnValue = getMountedApps();\n\n    if (callEventListeners) {\n      callAllEventListeners();\n    }\n    pendingPromises.forEach(promise => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName = wasNoOp ? \"single-spa:no-app-change\": \"single-spa:app-change\";\n      window.dispatchEvent(new CustomEvent(appChangeEventName, getCustomEventDetail()));\n      window.dispatchEvent(new CustomEvent(\"single-spa:routing-event\", getCustomEventDetail()));\n    } catch (err) {\n      /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    appChangeUnderway = false;\n\n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      peopleWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  function callAllEventListeners() {\n    pendingPromises.forEach(pendingPromise => {\n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n\n    callCapturedEventListeners(eventArguments);\n  }\n\n  function getCustomEventDetail() {\n    const result = {detail: {}}\n\n    if (eventArguments && eventArguments[0]) {\n      result.detail.originalEvent = eventArguments[0]\n    }\n\n    return result\n  }\n}\n","import { reroute } from './navigation/reroute.js';\n\nlet started = false;\n\nexport function start() {\n  started = true;\n  reroute();\n}\n\nexport function isStarted() {\n  return started;\n}\n\nconst startWarningDelay = 5000;\n\nsetTimeout(() => {\n  if (!started) {\n    console.warn(`singleSpa.start() has not been called, ${startWarningDelay}ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#start`);\n  }\n}, startWarningDelay)\n","import {getRawAppData, unregisterApplication} from '../applications/apps'\nimport {reroute} from '../navigation/reroute'\nimport {NOT_LOADED} from '../applications/app.helpers'\nimport {toLoadPromise} from '../lifecycles/load'\nimport {toBootstrapPromise} from '../lifecycles/bootstrap'\n\nexport default {\n  getRawAppData,\n  reroute,\n  NOT_LOADED,\n  toLoadPromise,\n  toBootstrapPromise,\n  unregisterApplication,\n}\n","export { start } from './start.js';\nexport { ensureJQuerySupport } from './jquery-support.js';\nexport { setBootstrapMaxTime, setMountMaxTime, setUnmountMaxTime, setUnloadMaxTime } from './applications/timeouts.js';\nexport { registerApplication, getMountedApps, getAppStatus, unloadApplication, checkActivityFunctions, getAppNames, declareChildApplication, unloadChildApplication } from './applications/apps.js';\nexport { navigateToUrl } from './navigation/navigation-events.js';\nexport { triggerAppChange } from './navigation/reroute.js';\nexport { addErrorHandler, removeErrorHandler } from './applications/app-errors.js';\nexport { mountRootParcel } from './parcels/mount-parcel.js';\n\nexport {\n  NOT_LOADED,\n  LOADING_SOURCE_CODE,\n  NOT_BOOTSTRAPPED,\n  BOOTSTRAPPING,\n  NOT_MOUNTED,\n  MOUNTING,\n  UPDATING,\n  LOAD_ERROR,\n  MOUNTED,\n  UNMOUNTING,\n  SKIP_BECAUSE_BROKEN,\n} from './applications/app.helpers.js';\n\nimport devtools from \"./devtools/devtools\"\nif(window && window.__SINGLE_SPA_DEVTOOLS__) {\n  window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { registerApplication, start, addErrorHandler, getAppStatus } from 'single-spa'\r\n\r\nconst commonContext = {\r\n    name: \"amin\",\r\n    hobby: [\"eat\", \"drink\", \"play\", \"happy\"]\r\n}\r\n\r\nregisterApplication(\r\n    'vue',\r\n    () => import(/* webpackChunkName: \"vue\" */'./src/vue/vue.app.js'),\r\n    pathPrefix(\"/vue\")\r\n)\r\n\r\n\r\nregisterApplication(\r\n    'profile',\r\n    () => import(/* webpackChunkName: \"profile\" */'./src/profile/react.app.js'),\r\n    pathPrefix(\"/profile\"),\r\n    {commonContext}\r\n)\r\n\r\nregisterApplication(\r\n    'admin',\r\n    () => import(/* webpackChunkName: \"admin\" */'./src/admin/react.app.js'),\r\n    pathPrefix(\"/admin\"),\r\n    {commonContext}\r\n)\r\n\r\nregisterApplication(\r\n    'nav',\r\n    () => import(/* webpackChunkName: \"nav\" */'./src/nav/react.app.js'),\r\n    () => true\r\n)\r\n\r\nstart()\r\n\r\nfunction pathPrefix(prefix) {\r\n    return function(location) {\r\n        return location.pathname.indexOf(`${prefix}`) === 0\r\n    }\r\n}\r\n"],"sourceRoot":""}